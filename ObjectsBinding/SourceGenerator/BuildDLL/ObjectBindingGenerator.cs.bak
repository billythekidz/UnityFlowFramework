﻿#if ROSLYN_SOURCE_GENERATOR
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;

[Generator]
public class ObjectBindingGenerator : ISourceGenerator
{
    // --- Data Models ---
    private class HierarchyNode { public string name { get; set; } public string[] components { get; set; } public List<HierarchyNode> children { get; set; } }
    private class CachedObject { public string className { get; set; } public HierarchyNode hierarchy { get; set; } }
    private class HierarchyCache { public List<CachedObject> objects { get; set; } }

    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        string cachePath = FindHierarchyCachePath(context);
        if (string.IsNullOrEmpty(cachePath) || !File.Exists(cachePath)) return;

        string jsonContent = File.ReadAllText(cachePath);
        if (string.IsNullOrEmpty(jsonContent)) return;

        HierarchyCache cache;
        try
        {
            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            cache = JsonSerializer.Deserialize<HierarchyCache>(jsonContent, options);
        }
        catch { return; }

        if (cache?.objects == null || cache.objects.Count == 0) return;
        var dataLookup = cache.objects.ToDictionary(o => o.className, o => o.hierarchy);

        var classesToGenerate = FindClassesWithAttribute(context.Compilation);

        foreach (var classSymbol in classesToGenerate)
        {
            if (dataLookup.TryGetValue(classSymbol.Name, out var hierarchy))
            {
                string sourceCode = GenerateSourceCodeForClass(classSymbol, hierarchy);
                context.AddSource($"{classSymbol.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
            }
        }
    }

    private string FindHierarchyCachePath(GeneratorExecutionContext context)
    {
        var anyFilePath = context.Compilation.SyntaxTrees.FirstOrDefault()?.FilePath;
        if (string.IsNullOrEmpty(anyFilePath)) return null;

        var directory = new DirectoryInfo(anyFilePath);
        while (directory != null && directory.Name != "Assets")
        {
            directory = directory.Parent;
        }
        if (directory == null) return null;

        return Path.Combine(directory.Parent.FullName, "Assets/LEARNING/GameFlowFramework/ObjectsBinding/Sync/HierarchyCache.json");
    }

    private IEnumerable<INamedTypeSymbol> FindClassesWithAttribute(Compilation compilation)
    {
        foreach (var syntaxTree in compilation.SyntaxTrees)
        {
            var semanticModel = compilation.GetSemanticModel(syntaxTree);
            var classNodes = syntaxTree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>();

            foreach (var classNode in classNodes)
            {
                if (classNode.AttributeLists.Any(al => al.Attributes.Any(a => a.Name.ToString().Contains("GenerateObjectBinding"))))
                {
                    yield return semanticModel.GetDeclaredSymbol(classNode);
                }
            }
        }
    }

    private string GenerateSourceCodeForClass(INamedTypeSymbol classSymbol, HierarchyNode rootNode)
    {
        var sb = new StringBuilder();
        string className = classSymbol.Name;
        string namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace ? null : classSymbol.ContainingNamespace.ToDisplayString();

        sb.AppendLine("using UnityEngine;");
        sb.AppendLine("using UnityEngine.UI;");
        sb.AppendLine("using System;");
        sb.AppendLine("using ObjectsBinding;");
        sb.AppendLine();
        sb.AppendLine($"// Auto-generated by ObjectBindingGenerator at {System.DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine();

        if (namespaceName != null) sb.AppendLine($"namespace {namespaceName} {{");
        
        sb.AppendLine($"    public partial class {className}");
        sb.AppendLine("    {");
        sb.AppendLine("#region Auto Generated Code For UI Bindings");
        sb.AppendLine();
        
        GenerateRootScopeProperties(sb, rootNode);
        
        sb.AppendLine("        private void Awake()");
        sb.AppendLine("        {");
        sb.AppendLine("            MappingReferences();");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        private void MappingReferences()");
        sb.AppendLine("        {");
        GenerateInitLogic(sb, rootNode);
        sb.AppendLine("        }");
        sb.AppendLine();

        GenerateNestedClasses(sb, rootNode);

        sb.AppendLine("#endregion");
        sb.AppendLine("    }");

        if (namespaceName != null) sb.AppendLine("}");

        return sb.ToString();
    }

    private void GenerateRootScopeProperties(StringBuilder sb, HierarchyNode root)
    {
        sb.AppendLine("        // ============ Serialized References (Flat for Editor) ============");
        CollectAllReferences(sb, root, "");
        
        sb.AppendLine();
        sb.AppendLine("        // ============ Public Nested Scope Properties ============");
        if (root.children != null)
        {
            foreach (var child in root.children)
            {
                string scopeName = child.name + "Scope";
                sb.AppendLine($"        public {scopeName} {child.name};");
            }
        }
    }

    private void CollectAllReferences(StringBuilder sb, HierarchyNode parent, string prefix)
    {
        if (parent.children == null) return;
        foreach (var child in parent.children)
        {
            string fieldPrefix = string.IsNullOrEmpty(prefix) ? child.name : $"{prefix}_{child.name}";
            
            sb.AppendLine($"        [SerializeField] private Transform _{fieldPrefix}_Transform;");
            sb.AppendLine($"        [SerializeField] private GameObject _{fieldPrefix}_GO;");
            
            if (child.components != null)
            {
                foreach (var compName in child.components)
                {
                    sb.AppendLine($"        [SerializeField] private {compName} _{fieldPrefix}_{compName};");
                }
            }
            sb.AppendLine();
            CollectAllReferences(sb, child, fieldPrefix);
        }
    }

    private void GenerateInitLogic(StringBuilder sb, HierarchyNode parent)
    {
        if (parent.children == null) return;
        foreach (var child in parent.children)
        {
            var args = new List<string>();
            CollectConstructorArgs(args, child, child.name);
            sb.AppendLine($"            this.{child.name} = new {child.name}Scope({string.Join(", ", args)});");
        }
    }

    private void CollectConstructorArgs(List<string> args, HierarchyNode parent, string parentFieldPrefix)
    {
        args.Add($"_{parentFieldPrefix}_Transform");
        args.Add($"_{parentFieldPrefix}_GO");
        if (parent.components != null)
        {
            foreach (var compName in parent.components) args.Add($"_{parentFieldPrefix}_{compName}");
        }

        if (parent.children != null)
        {
            foreach (var child in parent.children)
            {
                string childFieldPrefix = $"{parentFieldPrefix}_{child.name}";
                CollectConstructorArgs(args, child, childFieldPrefix);
            }
        }
    }

    private void GenerateNestedClasses(StringBuilder sb, HierarchyNode parent)
    {
        if (parent.children == null) return;
        foreach (var child in parent.children)
        {
            string scopeName = child.name + "Scope";
            
            sb.AppendLine();
            sb.AppendLine($"        public class {scopeName}");
            sb.AppendLine("        {");
            
            // Public readonly fields
            sb.AppendLine("            public readonly GameObject gameObject;");
            sb.AppendLine("            public readonly Transform transform;");
            if (child.components != null)
            {
                foreach (var compName in child.components) sb.AppendLine($"            public readonly {compName} {compName.ToLower()};");
            }
            if (child.children != null)
            {
                foreach (var grandChild in child.children) sb.AppendLine($"            public {grandChild.name}Scope {grandChild.name};");
            }

            // Constructor
            sb.AppendLine();
            var constructorParams = new List<string>();
            CollectConstructorParams(constructorParams, child, "");
            sb.AppendLine($"            public {scopeName}({string.Join(", ", constructorParams)})");
            sb.AppendLine("            {");
            GenerateConstructorBody(sb, child, "");
            sb.AppendLine("            }");
            sb.AppendLine("        }");

            // Recurse
            GenerateNestedClasses(sb, child);
        }
    }

    private void CollectConstructorParams(List<string> allParams, HierarchyNode parent, string prefix)
    {
        string paramPrefix = string.IsNullOrEmpty(prefix) ? "" : $"{prefix}_";
        allParams.Add($"Transform {paramPrefix}transform");
        allParams.Add($"GameObject {paramPrefix}gameObject");
        if (parent.components != null)
        {
            foreach (var compName in parent.components) allParams.Add($"{compName} {paramPrefix}{compName.ToLower()}");
        }
        if (parent.children != null)
        {
            foreach (var child in parent.children)
            {
                CollectConstructorParams(allParams, child, $"{paramPrefix}{child.name}");
            }
        }
    }

    private void GenerateConstructorBody(StringBuilder sb, HierarchyNode parent, string prefix)
    {
        string paramPrefix = string.IsNullOrEmpty(prefix) ? "" : $"{prefix}_";
        string thisPrefix = string.IsNullOrEmpty(prefix) ? "this" : $"this.{prefix}";

        sb.AppendLine($"                {thisPrefix}.transform = {paramPrefix}transform;");
        sb.AppendLine($"                {thisPrefix}.gameObject = {paramPrefix}gameObject;");

        if (parent.components != null)
        {
            foreach (var compName in parent.components)
            {
                sb.AppendLine($"                {thisPrefix}.{compName.ToLower()} = {paramPrefix}{compName.ToLower()};");
            }
        }

        if (parent.children != null)
        {
            foreach (var child in parent.children)
            {
                var nestedArgs = new List<string>();
                CollectNestedConstructorArgs(nestedArgs, child, $"{paramPrefix}{child.name}");
                sb.AppendLine($"                {thisPrefix}.{child.name} = new {child.name}Scope({string.Join(", ", nestedArgs)});");
            }
        }
    }

    private void CollectNestedConstructorArgs(List<string> nestedArgs, HierarchyNode parent, string prefix)
    {
        nestedArgs.Add($"{prefix}_transform");
        nestedArgs.Add($"{prefix}_gameObject");
        if (parent.components != null)
        {
            foreach (var compName in parent.components) nestedArgs.Add($"{prefix}_{compName.ToLower()}");
        }
        if (parent.children != null)
        {
            foreach (var child in parent.children)
            {
                CollectNestedConstructorArgs(nestedArgs, child, $"{prefix}_{child.name}");
            }
        }
    }
}
#endif
